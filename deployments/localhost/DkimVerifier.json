{
  "address": "0x712516e61C8B383dF4A63CFe83d7701Bce54B03e",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_keys",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "from",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "hash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "subject",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "server",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "verify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xd99de0da8955c851eff5fa981a2f90520b31c99d24b00bdc6b9a4c886102e23a",
  "receipt": {
    "to": null,
    "from": "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
    "contractAddress": "0x712516e61C8B383dF4A63CFe83d7701Bce54B03e",
    "transactionIndex": 0,
    "gasUsed": "656468",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x6f257e4329172a8b1a890540300364a6f19bb7d2a7a8668e2b7a957de0685dfb",
    "transactionHash": "0xd99de0da8955c851eff5fa981a2f90520b31c99d24b00bdc6b9a4c886102e23a",
    "logs": [],
    "blockNumber": 5,
    "cumulativeGasUsed": "656468",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x948B3c65b89DF0B4894ABE91E6D02FE579834F8F"
  ],
  "numDeployments": 1,
  "solcInputHash": "be222504d6281d379979e56804b0c406",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keys\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"from\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"hash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"subject\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"server\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/solidity-dkim/src/DkimVerifier.sol\":\"DkimVerifier\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[]},\"sources\":{\"lib/solidity-dkim/lib/solmate/src/auth/Owned.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xfedb27d14c508342c33eb067c9a02eabcdb0f9dcf93b04ded1001f580d12d0ea\",\"license\":\"AGPL-3.0-only\"},\"lib/solidity-dkim/src/DkimKeys.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"../lib/solmate/src/auth/Owned.sol\\\";\\n\\ncontract DkimKeys is Owned {\\n    event UpdateDKIMKey(bytes32 server, bytes key);\\n    event DeleteDKIMKey(bytes32 server, bytes key);\\n\\n    mapping(bytes32 => bytes) private dkimKeys;\\n\\n    constructor() Owned(msg.sender) {}\\n\\n    function updateKey(bytes32 server, bytes memory key) external onlyOwner {\\n        dkimKeys[server] = key;\\n        emit UpdateDKIMKey(server, key);\\n    }\\n\\n    function removeKey(bytes32 server) external onlyOwner {\\n        bytes memory key = dkimKeys[server];\\n        delete dkimKeys[server];\\n        emit DeleteDKIMKey(server, key);\\n    }\\n\\n    function getKey(bytes32 server) external view returns (bytes memory) {\\n        bytes memory key = dkimKeys[server];\\n        require(key.length > 0, \\\"no key\\\");\\n        return key;\\n    }\\n}\\n\",\"keccak256\":\"0x9fd729127d5f2f065b6e81bc20c74118f2629627bafda0697f0636cd5f790fb7\",\"license\":\"MIT\"},\"lib/solidity-dkim/src/DkimVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {DkimKeys} from \\\"./DkimKeys.sol\\\";\\nimport {BytesUtils} from \\\"./lib/BytesUtils.sol\\\";\\nimport {RSAVerifier} from \\\"./lib/RSAVerifier.sol\\\";\\n\\ncontract DkimVerifier {\\n    using BytesUtils for bytes;\\n\\n    DkimKeys private keys;\\n\\n    constructor(address _keys) {\\n        keys = DkimKeys(_keys);\\n    }\\n\\n    function from(bytes memory data) public pure returns (bytes memory) {\\n        uint32 index = data.toUint32(0);\\n        uint32 length = data.toUint32(4);\\n        return data.slice(index, length);\\n    }\\n\\n    function subject(bytes memory data) public pure returns (bytes memory) {\\n        uint32 index = data.toUint32(8);\\n        uint32 length = data.toUint32(12);\\n        return data.slice(index, length);\\n    }\\n\\n    function hash(bytes memory data) public pure returns (bytes32) {\\n        return sha256(data.slice(16, data.length - 16));\\n    }\\n\\n    function verify(bytes32 server, bytes calldata data, bytes calldata signature) external view returns (bool) {\\n        bytes memory modulus = keys.getKey(server);\\n        bool ok;\\n        bytes memory result;\\n        (ok, result) = RSAVerifier.rsaRecover(modulus, hex\\\"010001\\\", signature);\\n        return ok && hash(data) == result.toBytes32(result.length - 32);\\n    }\\n}\\n\",\"keccak256\":\"0xf6f800e96e5e168c2c34180241673a1e32dc67cafe60425f37076b90527b6cc3\",\"license\":\"MIT\"},\"lib/solidity-dkim/src/lib/Buffer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n/**\\n * @dev A library for working with mutable byte buffers in Solidity.\\n *\\n * Byte buffers are mutable and expandable, and provide a variety of primitives\\n * for writing to them. At any time you can fetch a bytes object containing the\\n * current contents of the buffer. The bytes object should not be stored between\\n * operations, as it may change due to resizing of the buffer.\\n */\\nlibrary Buffer {\\n    /**\\n     * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n     *      a capacity. The capacity may be longer than the current value, in\\n     *      which case it can be extended without the need to allocate more memory.\\n     */\\n    struct buffer {\\n        bytes buf;\\n        uint256 capacity;\\n    }\\n\\n    /**\\n     * @dev Initializes a buffer with an initial capacity.\\n     * @param buf The buffer to initialize.\\n     * @param capacity The number of bytes of space to allocate the buffer.\\n     * @return The buffer, for chaining.\\n     */\\n    function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\\n        if (capacity % 32 != 0) {\\n            capacity += 32 - (capacity % 32);\\n        }\\n        // Allocate space for the buffer data\\n        buf.capacity = capacity;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(buf, ptr)\\n            mstore(ptr, 0)\\n            mstore(0x40, add(32, add(ptr, capacity)))\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n     * @dev Initializes a new buffer from an existing bytes object.\\n     *      Changes to the buffer may mutate the original value.\\n     * @param b The bytes object to initialize the buffer with.\\n     * @return A new buffer.\\n     */\\n    function fromBytes(bytes memory b) internal pure returns (buffer memory) {\\n        buffer memory buf;\\n        buf.buf = b;\\n        buf.capacity = b.length;\\n        return buf;\\n    }\\n\\n    function resize(buffer memory buf, uint256 capacity) private pure {\\n        bytes memory oldbuf = buf.buf;\\n        init(buf, capacity);\\n        append(buf, oldbuf);\\n    }\\n\\n    function max(uint256 a, uint256 b) private pure returns (uint256) {\\n        if (a > b) {\\n            return a;\\n        }\\n        return b;\\n    }\\n\\n    /**\\n     * @dev Sets buffer length to 0.\\n     * @param buf The buffer to truncate.\\n     * @return The original buffer, for chaining..\\n     */\\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\\n        assembly {\\n            let bufptr := mload(buf)\\n            mstore(bufptr, 0)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\\n     *      the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param off The start offset to write to.\\n     * @param data The data to append.\\n     * @param len The number of bytes to copy.\\n     * @return The original buffer, for chaining.\\n     */\\n    function write(\\n        buffer memory buf,\\n        uint256 off,\\n        bytes memory data,\\n        uint256 len\\n    ) internal pure returns (buffer memory) {\\n        require(len <= data.length);\\n\\n        if (off + len > buf.capacity) {\\n            resize(buf, max(buf.capacity, len + off) * 2);\\n        }\\n\\n        uint256 dest;\\n        uint256 src;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Start address = buffer address + offset + sizeof(buffer length)\\n            dest := add(add(bufptr, 32), off)\\n            // Update buffer length if we're extending it\\n            if gt(add(len, off), buflen) {\\n                mstore(bufptr, add(len, off))\\n            }\\n            src := add(data, 32)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint256 mask = 256 ** (32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n     * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n     *      the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @param len The number of bytes to copy.\\n     * @return The original buffer, for chaining.\\n     */\\n    function append(buffer memory buf, bytes memory data, uint256 len) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, len);\\n    }\\n\\n    /**\\n     * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n     *      the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @return The original buffer, for chaining.\\n     */\\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, data.length);\\n    }\\n\\n    /**\\n     * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\\n     *      capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param off The offset to write the byte at.\\n     * @param data The data to append.\\n     * @return The original buffer, for chaining.\\n     */\\n    function writeUint8(buffer memory buf, uint256 off, uint8 data) internal pure returns (buffer memory) {\\n        if (off > buf.capacity) {\\n            resize(buf, buf.capacity * 2);\\n        }\\n\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Address = buffer address + sizeof(buffer length) + off\\n            let dest := add(add(bufptr, off), 32)\\n            mstore8(dest, data)\\n            // Update buffer length if we extended it\\n            if eq(off, buflen) {\\n                mstore(bufptr, add(buflen, 1))\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n     * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n     *      capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @return The original buffer, for chaining.\\n     */\\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\\n        return writeUint8(buf, buf.buf.length, data);\\n    }\\n\\n    /**\\n     * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\\n     *      exceed the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param off The offset to write at.\\n     * @param data The data to append.\\n     * @param len The number of bytes to write (left-aligned).\\n     * @return The original buffer, for chaining.\\n     */\\n    function write(buffer memory buf, uint256 off, bytes32 data, uint256 len) private pure returns (buffer memory) {\\n        if (len + off > buf.capacity) {\\n            resize(buf, max(buf.capacity, len) * 2);\\n        }\\n\\n        uint256 mask = 256 ** len - 1;\\n        // Right-align data\\n        data = data >> (8 * (32 - len));\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + sizeof(buffer length) + off + len\\n            let dest := add(add(bufptr, off), len)\\n            mstore(dest, or(and(mload(dest), not(mask)), data))\\n            // Update buffer length if we extended it\\n            if gt(add(off, len), mload(bufptr)) {\\n                mstore(bufptr, add(off, len))\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n     * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\\n     *      capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param off The offset to write at.\\n     * @param data The data to append.\\n     * @return The original buffer, for chaining.\\n     */\\n    function writeBytes20(buffer memory buf, uint256 off, bytes20 data) internal pure returns (buffer memory) {\\n        return write(buf, off, bytes32(data), 20);\\n    }\\n\\n    /**\\n     * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n     *      the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @return The original buffer, for chhaining.\\n     */\\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, bytes32(data), 20);\\n    }\\n\\n    /**\\n     * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n     *      the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @return The original buffer, for chaining.\\n     */\\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, 32);\\n    }\\n\\n    /**\\n     * @dev Writes an integer to the buffer. Resizes if doing so would exceed\\n     *      the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param off The offset to write at.\\n     * @param data The data to append.\\n     * @param len The number of bytes to write (right-aligned).\\n     * @return The original buffer, for chaining.\\n     */\\n    function writeInt(buffer memory buf, uint256 off, uint256 data, uint256 len) private pure returns (buffer memory) {\\n        if (len + off > buf.capacity) {\\n            resize(buf, max(buf.capacity, len + off) * 2);\\n        }\\n\\n        uint256 mask = 256 ** len - 1;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + off + sizeof(buffer length) + len\\n            let dest := add(add(bufptr, off), len)\\n            mstore(dest, or(and(mload(dest), not(mask)), data))\\n            // Update buffer length if we extended it\\n            if gt(add(off, len), mload(bufptr)) {\\n                mstore(bufptr, add(off, len))\\n            }\\n        }\\n        return buf;\\n    }\\n}\\n\",\"keccak256\":\"0xd874460c1d2bbd2da87f4ae5d91c132a13d5c9b0f5f7dfa8371bfd59ba3ca33a\",\"license\":\"MIT\"},\"lib/solidity-dkim/src/lib/BytesUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nlibrary BytesUtils {\\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(\\n                0x40,\\n                and(\\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n                    not(31) // Round down to the nearest 32 bytes.\\n                )\\n            )\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1, \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                } // while(uint256(mc < end) + cb == 2) // the next line is the loop condition:\\n                eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {\\n\\n                        } eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0xe3abe7da378dead0e9629f6271da9a0312ce327aa2e911e84e414b2a870576b2\",\"license\":\"MIT\"},\"lib/solidity-dkim/src/lib/ModexpPrecompile.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"./Buffer.sol\\\";\\n\\nlibrary ModexpPrecompile {\\n    using Buffer for *;\\n\\n    /**\\n     * @dev Computes (base ^ exponent) % modulus over big numbers.\\n     */\\n    function modexp(\\n        bytes memory base,\\n        bytes memory exponent,\\n        bytes memory modulus\\n    ) internal view returns (bool success, bytes memory output) {\\n        bytes memory input = abi.encodePacked(\\n            uint256(base.length),\\n            uint256(exponent.length),\\n            uint256(modulus.length),\\n            base,\\n            exponent,\\n            modulus\\n        );\\n\\n        output = new bytes(modulus.length);\\n\\n        assembly {\\n            success := staticcall(gas(), 5, add(input, 32), mload(input), add(output, 32), mload(modulus))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaf9867d889b525c512109894aa81e9af414081155d4bfe53f586d3ca18ed572f\",\"license\":\"MIT\"},\"lib/solidity-dkim/src/lib/RSAVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"./ModexpPrecompile.sol\\\";\\n\\nlibrary RSAVerifier {\\n    /**\\n     * @dev Recovers the input data from an RSA signature, returning the result in S.\\n     * @param N The RSA public modulus.\\n     * @param E The RSA public exponent.\\n     * @param S The signature to recover.\\n     * @return True if the recovery succeeded.\\n     */\\n    function rsaRecover(bytes memory N, bytes memory E, bytes memory S) internal view returns (bool, bytes memory) {\\n        return ModexpPrecompile.modexp(S, E, N);\\n    }\\n}\\n\",\"keccak256\":\"0xe9822a40235d5019eabb260f55d933c6b40d8ece8c761e9dd970b1dbb61a828b\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50604051610b1b380380610b1b83398101604081905261002f91610054565b600080546001600160a01b0319166001600160a01b0392909216919091179055610084565b60006020828403121561006657600080fd5b81516001600160a01b038116811461007d57600080fd5b9392505050565b610a88806100936000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c8063391c87c8146100515780635bf48e3a1461007a578063a3364fd91461009d578063aa1e84de146100b0575b600080fd5b61006461005f366004610738565b6100d1565b60405161007191906107dc565b60405180910390f35b61008d610088366004610876565b61010f565b6040519015158152602001610071565b6100646100ab366004610738565b6102b4565b6100c36100be366004610738565b6102d2565b604051908152602001610071565b606060006100df8382610343565b905060006100ee846004610343565b90506101078463ffffffff80851690808516906103c816565b949350505050565b600080546040517f12aaac7000000000000000000000000000000000000000000000000000000000815260048101889052829173ffffffffffffffffffffffffffffffffffffffff16906312aaac7090602401600060405180830381865afa15801561017f573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682016040526101c591908101906108f0565b905060006060610241836040518060400160405280600381526020017f010001000000000000000000000000000000000000000000000000000000000081525088888080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061054292505050565b90925090508180156102a757506102666020825161025f9190610996565b829061055d565b6102a589898080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506102d292505050565b145b9998505050505050505050565b606060006102c3836008610343565b905060006100ee84600c610343565b600060026102f060108085516102e89190610996565b8591906103c8565b6040516102fd91906109a9565b602060405180830381855afa15801561031a573d6000803e3d6000fd5b5050506040513d601f19601f8201168201806040525081019061033d91906109c5565b92915050565b60006103508260046109de565b835110156103bf576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f746f55696e7433325f6f75744f66426f756e647300000000000000000000000060448201526064015b60405180910390fd5b50016004015190565b6060816103d681601f6109de565b101561043e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f7700000000000000000000000000000000000060448201526064016103b6565b61044882846109de565b845110156104b2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f736c6963655f6f75744f66426f756e647300000000000000000000000000000060448201526064016103b6565b6060821580156104d15760405191506000825260208201604052610539565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561050a5780518352602092830192016104f2565b5050858452601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016604052505b50949350505050565b600060606105518385876105dd565b91509150935093915050565b600061056a8260206109de565b835110156105d4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f746f427974657333325f6f75744f66426f756e6473000000000000000000000060448201526064016103b6565b50016020015190565b600060606000855185518551888888604051602001610601969594939291906109f1565b6040516020818303038152906040529050835167ffffffffffffffff81111561062c5761062c610674565b6040519080825280601f01601f191660200182016040528015610656576020820181803683370190505b50915083516020830182516020840160055afa925050935093915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156106ea576106ea610674565b604052919050565b600067ffffffffffffffff82111561070c5761070c610674565b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b60006020828403121561074a57600080fd5b813567ffffffffffffffff81111561076157600080fd5b8201601f8101841361077257600080fd5b8035610785610780826106f2565b6106a3565b81815285602083850101111561079a57600080fd5b81602084016020830137600091810160200191909152949350505050565b60005b838110156107d35781810151838201526020016107bb565b50506000910152565b60208152600082518060208401526107fb8160408501602087016107b8565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b60008083601f84011261083f57600080fd5b50813567ffffffffffffffff81111561085757600080fd5b60208301915083602082850101111561086f57600080fd5b9250929050565b60008060008060006060868803121561088e57600080fd5b85359450602086013567ffffffffffffffff808211156108ad57600080fd5b6108b989838a0161082d565b909650945060408801359150808211156108d257600080fd5b506108df8882890161082d565b969995985093965092949392505050565b60006020828403121561090257600080fd5b815167ffffffffffffffff81111561091957600080fd5b8201601f8101841361092a57600080fd5b8051610938610780826106f2565b81815285602083850101111561094d57600080fd5b61095e8260208301602086016107b8565b95945050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8181038181111561033d5761033d610967565b600082516109bb8184602087016107b8565b9190910192915050565b6000602082840312156109d757600080fd5b5051919050565b8082018082111561033d5761033d610967565b86815285602082015284604082015260008451610a158160608501602089016107b8565b845190830190610a2c8160608401602089016107b8565b8451910190610a428160608401602088016107b8565b016060019897505050505050505056fea2646970667358221220fb5c527e183cfa28f55ee52113a4aecadaa90506d24bba1d700d22cd942ad3ac64736f6c63430008130033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c8063391c87c8146100515780635bf48e3a1461007a578063a3364fd91461009d578063aa1e84de146100b0575b600080fd5b61006461005f366004610738565b6100d1565b60405161007191906107dc565b60405180910390f35b61008d610088366004610876565b61010f565b6040519015158152602001610071565b6100646100ab366004610738565b6102b4565b6100c36100be366004610738565b6102d2565b604051908152602001610071565b606060006100df8382610343565b905060006100ee846004610343565b90506101078463ffffffff80851690808516906103c816565b949350505050565b600080546040517f12aaac7000000000000000000000000000000000000000000000000000000000815260048101889052829173ffffffffffffffffffffffffffffffffffffffff16906312aaac7090602401600060405180830381865afa15801561017f573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682016040526101c591908101906108f0565b905060006060610241836040518060400160405280600381526020017f010001000000000000000000000000000000000000000000000000000000000081525088888080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061054292505050565b90925090508180156102a757506102666020825161025f9190610996565b829061055d565b6102a589898080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506102d292505050565b145b9998505050505050505050565b606060006102c3836008610343565b905060006100ee84600c610343565b600060026102f060108085516102e89190610996565b8591906103c8565b6040516102fd91906109a9565b602060405180830381855afa15801561031a573d6000803e3d6000fd5b5050506040513d601f19601f8201168201806040525081019061033d91906109c5565b92915050565b60006103508260046109de565b835110156103bf576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f746f55696e7433325f6f75744f66426f756e647300000000000000000000000060448201526064015b60405180910390fd5b50016004015190565b6060816103d681601f6109de565b101561043e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f7700000000000000000000000000000000000060448201526064016103b6565b61044882846109de565b845110156104b2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f736c6963655f6f75744f66426f756e647300000000000000000000000000000060448201526064016103b6565b6060821580156104d15760405191506000825260208201604052610539565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561050a5780518352602092830192016104f2565b5050858452601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016604052505b50949350505050565b600060606105518385876105dd565b91509150935093915050565b600061056a8260206109de565b835110156105d4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f746f427974657333325f6f75744f66426f756e6473000000000000000000000060448201526064016103b6565b50016020015190565b600060606000855185518551888888604051602001610601969594939291906109f1565b6040516020818303038152906040529050835167ffffffffffffffff81111561062c5761062c610674565b6040519080825280601f01601f191660200182016040528015610656576020820181803683370190505b50915083516020830182516020840160055afa925050935093915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156106ea576106ea610674565b604052919050565b600067ffffffffffffffff82111561070c5761070c610674565b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b60006020828403121561074a57600080fd5b813567ffffffffffffffff81111561076157600080fd5b8201601f8101841361077257600080fd5b8035610785610780826106f2565b6106a3565b81815285602083850101111561079a57600080fd5b81602084016020830137600091810160200191909152949350505050565b60005b838110156107d35781810151838201526020016107bb565b50506000910152565b60208152600082518060208401526107fb8160408501602087016107b8565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b60008083601f84011261083f57600080fd5b50813567ffffffffffffffff81111561085757600080fd5b60208301915083602082850101111561086f57600080fd5b9250929050565b60008060008060006060868803121561088e57600080fd5b85359450602086013567ffffffffffffffff808211156108ad57600080fd5b6108b989838a0161082d565b909650945060408801359150808211156108d257600080fd5b506108df8882890161082d565b969995985093965092949392505050565b60006020828403121561090257600080fd5b815167ffffffffffffffff81111561091957600080fd5b8201601f8101841361092a57600080fd5b8051610938610780826106f2565b81815285602083850101111561094d57600080fd5b61095e8260208301602086016107b8565b95945050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8181038181111561033d5761033d610967565b600082516109bb8184602087016107b8565b9190910192915050565b6000602082840312156109d757600080fd5b5051919050565b8082018082111561033d5761033d610967565b86815285602082015284604082015260008451610a158160608501602089016107b8565b845190830190610a2c8160608401602089016107b8565b8451910190610a428160608401602088016107b8565b016060019897505050505050505056fea2646970667358221220fb5c527e183cfa28f55ee52113a4aecadaa90506d24bba1d700d22cd942ad3ac64736f6c63430008130033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 9255,
        "contract": "lib/solidity-dkim/src/DkimVerifier.sol:DkimVerifier",
        "label": "keys",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(DkimKeys)9241"
      }
    ],
    "types": {
      "t_contract(DkimKeys)9241": {
        "encoding": "inplace",
        "label": "contract DkimKeys",
        "numberOfBytes": "20"
      }
    }
  }
}