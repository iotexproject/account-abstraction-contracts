{
  "address": "0xd37da777EA5f9356849fe4d8973dCdF95B3ED8B9",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "addresses",
          "type": "address[]"
        }
      ],
      "name": "getCodeHashes",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IEntryPoint",
          "name": "entryPoint",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "initCode",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            },
            {
              "internalType": "uint256",
              "name": "callGasLimit",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "verificationGasLimit",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "preVerificationGas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxFeePerGas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxPriorityFeePerGas",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "paymasterAndData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct UserOperation[]",
          "name": "userOps",
          "type": "tuple[]"
        }
      ],
      "name": "getUserOpHashes",
      "outputs": [
        {
          "internalType": "bytes32[]",
          "name": "ret",
          "type": "bytes32[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xf5fa5cf1f7b4254edcc531e2348425e86df5997a1eeba69898a5a748bb4fc5e0",
  "receipt": {
    "to": "0x355BE1cbfFBf803fdb17E0CB207D051cD9816916",
    "from": "0x8896780a7912829781f70344Ab93E589dDdb2930",
    "contractAddress": null,
    "transactionIndex": 0,
    "gasUsed": "763915",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xb772c471029f863ad84db2aac3f1709845f28180d678b10490527e7df072fcee",
    "transactionHash": "0xf5fa5cf1f7b4254edcc531e2348425e86df5997a1eeba69898a5a748bb4fc5e0",
    "logs": [],
    "blockNumber": 19196511,
    "cumulativeGasUsed": "763915",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 3,
  "solcInputHash": "063069730b1d494d3b4f3cfaa4d8a893",
  "metadata": "{\"compiler\":{\"version\":\"0.8.15+commit.e14f2714\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"getCodeHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IEntryPoint\",\"name\":\"entryPoint\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation[]\",\"name\":\"userOps\",\"type\":\"tuple[]\"}],\"name\":\"getUserOpHashes\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"ret\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/misc/BundlerHelper.sol\":\"BundlerHelper\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[]},\"sources\":{\"contracts/interfaces/IAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./UserOperation.sol\\\";\\n\\n/**\\n * Aggregated Signatures validator.\\n */\\ninterface IAggregator {\\n    /**\\n     * validate aggregated signature.\\n     * revert if the aggregated signature does not match the given list of operations.\\n     */\\n    function validateSignatures(UserOperation[] calldata userOps, bytes calldata signature)\\n        external\\n        view;\\n\\n    /**\\n     * validate signature of a single userOp\\n     * This method is should be called by bundler after EntryPoint.simulateValidation() returns (reverts) with ValidationResultWithAggregation\\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\\n     * @param userOp the userOperation received from the user.\\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\\n     *    (usually empty, unless account and aggregator support some kind of \\\"multisig\\\"\\n     */\\n    function validateUserOpSignature(UserOperation calldata userOp)\\n        external\\n        view\\n        returns (bytes memory sigForUserOp);\\n\\n    /**\\n     * aggregate multiple signatures into a single value.\\n     * This method is called off-chain to calculate the signature to pass with handleOps()\\n     * bundler MAY use optimized custom code perform this aggregation\\n     * @param userOps array of UserOperations to collect the signatures from.\\n     * @return aggregatedSignature the aggregated signature\\n     */\\n    function aggregateSignatures(UserOperation[] calldata userOps)\\n        external\\n        view\\n        returns (bytes memory aggregatedSignature);\\n}\\n\",\"keccak256\":\"0x82ed8afa7f2d0e342369a0309eb8a188266912656d469cd70795057a9b6a267f\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IEntryPoint.sol\":{\"content\":\"/**\\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\\n ** Only one instance required on each chain.\\n **/\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-inline-assembly */\\n/* solhint-disable reason-string */\\n\\nimport \\\"./UserOperation.sol\\\";\\nimport \\\"./IStakeManager.sol\\\";\\nimport \\\"./IAggregator.sol\\\";\\n\\ninterface IEntryPoint is IStakeManager {\\n    /***\\n     * An event emitted after each successful request\\n     * @param userOpHash - unique identifier for the request (hash its entire content, except signature).\\n     * @param sender - the account that generates this request.\\n     * @param paymaster - if non-null, the paymaster that pays for this request.\\n     * @param nonce - the nonce value from the request.\\n     * @param success - true if the sender transaction succeeded, false if reverted.\\n     * @param actualGasCost - actual amount paid (by account or paymaster) for this UserOperation.\\n     * @param actualGasUsed - total gas used by this UserOperation (including preVerification, creation, validation and execution).\\n     */\\n    event UserOperationEvent(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        address indexed paymaster,\\n        uint256 nonce,\\n        bool success,\\n        uint256 actualGasCost,\\n        uint256 actualGasUsed\\n    );\\n\\n    /**\\n     * account \\\"sender\\\" was deployed.\\n     * @param userOpHash the userOp that deployed this account. UserOperationEvent will follow.\\n     * @param sender the account that is deployed\\n     * @param factory the factory used to deploy this account (in the initCode)\\n     * @param paymaster the paymaster used by this UserOp\\n     */\\n    event AccountDeployed(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        address factory,\\n        address paymaster\\n    );\\n\\n    /**\\n     * An event emitted if the UserOperation \\\"callData\\\" reverted with non-zero length\\n     * @param userOpHash the request unique identifier.\\n     * @param sender the sender of this request\\n     * @param nonce the nonce used in the request\\n     * @param revertReason - the return bytes from the (reverted) call to \\\"callData\\\".\\n     */\\n    event UserOperationRevertReason(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        uint256 nonce,\\n        bytes revertReason\\n    );\\n\\n    /**\\n     * signature aggregator used by the following UserOperationEvents within this bundle.\\n     */\\n    event SignatureAggregatorChanged(address indexed aggregator);\\n\\n    /**\\n     * a custom revert error of handleOps, to identify the offending op.\\n     *  NOTE: if simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\\n     *  @param opIndex - index into the array of ops to the failed one (in simulateValidation, this is always zero)\\n     *  @param reason - revert reason\\n     *      The string starts with a unique code \\\"AAmn\\\", where \\\"m\\\" is \\\"1\\\" for factory, \\\"2\\\" for account and \\\"3\\\" for paymaster issues,\\n     *      so a failure can be attributed to the correct entity.\\n     *   Should be caught in off-chain handleOps simulation and not happen on-chain.\\n     *   Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\\n     */\\n    error FailedOp(uint256 opIndex, string reason);\\n\\n    /**\\n     * error case when a signature aggregator fails to verify the aggregated signature it had created.\\n     */\\n    error SignatureValidationFailed(address aggregator);\\n\\n    /**\\n     * Successful result from simulateValidation.\\n     * @param returnInfo gas and time-range returned values\\n     * @param senderInfo stake information about the sender\\n     * @param factoryInfo stake information about the factory (if any)\\n     * @param paymasterInfo stake information about the paymaster (if any)\\n     */\\n    error ValidationResult(\\n        ReturnInfo returnInfo,\\n        StakeInfo senderInfo,\\n        StakeInfo factoryInfo,\\n        StakeInfo paymasterInfo\\n    );\\n\\n    /**\\n     * Successful result from simulateValidation, if the account returns a signature aggregator\\n     * @param returnInfo gas and time-range returned values\\n     * @param senderInfo stake information about the sender\\n     * @param factoryInfo stake information about the factory (if any)\\n     * @param paymasterInfo stake information about the paymaster (if any)\\n     * @param aggregatorInfo signature aggregation info (if the account requires signature aggregator)\\n     *      bundler MUST use it to verify the signature, or reject the UserOperation\\n     */\\n    error ValidationResultWithAggregation(\\n        ReturnInfo returnInfo,\\n        StakeInfo senderInfo,\\n        StakeInfo factoryInfo,\\n        StakeInfo paymasterInfo,\\n        AggregatorStakeInfo aggregatorInfo\\n    );\\n\\n    /**\\n     * return value of getSenderAddress\\n     */\\n    error SenderAddressResult(address sender);\\n\\n    /**\\n     * return value of simulateHandleOp\\n     */\\n    error ExecutionResult(\\n        uint256 preOpGas,\\n        uint256 paid,\\n        uint48 validAfter,\\n        uint48 validUntil,\\n        bool targetSuccess,\\n        bytes targetResult\\n    );\\n\\n    //UserOps handled, per aggregator\\n    struct UserOpsPerAggregator {\\n        UserOperation[] userOps;\\n        // aggregator address\\n        IAggregator aggregator;\\n        // aggregated signature\\n        bytes signature;\\n    }\\n\\n    /**\\n     * Execute a batch of UserOperation.\\n     * no signature aggregator is used.\\n     * if any account requires an aggregator (that is, it returned an aggregator when\\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\\n     * @param ops the operations to execute\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) external;\\n\\n    /**\\n     * Execute a batch of UserOperation with Aggregators\\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleAggregatedOps(\\n        UserOpsPerAggregator[] calldata opsPerAggregator,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * generate a request Id - unique identifier for this request.\\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\\n     */\\n    function getUserOpHash(UserOperation calldata userOp) external view returns (bytes32);\\n\\n    /**\\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\\n     * @param userOp the user operation to validate.\\n     */\\n    function simulateValidation(UserOperation calldata userOp) external;\\n\\n    /**\\n     * gas and return values during simulation\\n     * @param preOpGas the gas used for validation (including preValidationGas)\\n     * @param prefund the required prefund for this operation\\n     * @param sigFailed validateUserOp's (or paymaster's) signature check failed\\n     * @param validAfter - first timestamp this UserOp is valid (merging account and paymaster time-range)\\n     * @param validUntil - last timestamp this UserOp is valid (merging account and paymaster time-range)\\n     * @param paymasterContext returned by validatePaymasterUserOp (to be passed into postOp)\\n     */\\n    struct ReturnInfo {\\n        uint256 preOpGas;\\n        uint256 prefund;\\n        bool sigFailed;\\n        uint48 validAfter;\\n        uint48 validUntil;\\n        bytes paymasterContext;\\n    }\\n\\n    /**\\n     * returned aggregated signature info.\\n     * the aggregator returned by the account, and its current stake.\\n     */\\n    struct AggregatorStakeInfo {\\n        address aggregator;\\n        StakeInfo stakeInfo;\\n    }\\n\\n    /**\\n     * Get counterfactual sender address.\\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\\n     * this method always revert, and returns the address in SenderAddressResult error\\n     * @param initCode the constructor code to be passed into the UserOperation.\\n     */\\n    function getSenderAddress(bytes memory initCode) external;\\n\\n    /**\\n     * simulate full execution of a UserOperation (including both validation and target execution)\\n     * this method will always revert with \\\"ExecutionResult\\\".\\n     * it performs full validation of the UserOperation, but ignores signature error.\\n     * an optional target address is called after the userop succeeds, and its value is returned\\n     * (before the entire call is reverted)\\n     * Note that in order to collect the the success/failure of the target call, it must be executed\\n     * with trace enabled to track the emitted events.\\n     * @param op the UserOperation to simulate\\n     * @param target if nonzero, a target address to call after userop simulation. If called, the targetSuccess and targetResult\\n     *        are set to the return from that call.\\n     * @param targetCallData callData to pass to target address\\n     */\\n    function simulateHandleOp(\\n        UserOperation calldata op,\\n        address target,\\n        bytes calldata targetCallData\\n    ) external;\\n}\\n\",\"keccak256\":\"0x5d0c808dbcdafa44e36f3da39a606be24ac634900aa33c9eefd1c53ce75cc1f5\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IStakeManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.12;\\n\\n/**\\n * manage deposits and stakes.\\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\\n * stake is value locked for at least \\\"unstakeDelay\\\" by the staked entity.\\n */\\ninterface IStakeManager {\\n    event Deposited(address indexed account, uint256 totalDeposit);\\n\\n    event Withdrawn(address indexed account, address withdrawAddress, uint256 amount);\\n\\n    /// Emitted when stake or unstake delay are modified\\n    event StakeLocked(address indexed account, uint256 totalStaked, uint256 unstakeDelaySec);\\n\\n    /// Emitted once a stake is scheduled for withdrawal\\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\\n\\n    event StakeWithdrawn(address indexed account, address withdrawAddress, uint256 amount);\\n\\n    /**\\n     * @param deposit the entity's deposit\\n     * @param staked true if this entity is staked.\\n     * @param stake actual amount of ether staked for this entity.\\n     * @param unstakeDelaySec minimum delay to withdraw the stake.\\n     * @param withdrawTime - first block timestamp where 'withdrawStake' will be callable, or zero if already locked\\n     * @dev sizes were chosen so that (deposit,staked, stake) fit into one cell (used during handleOps)\\n     *    and the rest fit into a 2nd cell.\\n     *    112 bit allows for 10^15 eth\\n     *    48 bit for full timestamp\\n     *    32 bit allows 150 years for unstake delay\\n     */\\n    struct DepositInfo {\\n        uint112 deposit;\\n        bool staked;\\n        uint112 stake;\\n        uint32 unstakeDelaySec;\\n        uint48 withdrawTime;\\n    }\\n\\n    //API struct used by getStakeInfo and simulateValidation\\n    struct StakeInfo {\\n        uint256 stake;\\n        uint256 unstakeDelaySec;\\n    }\\n\\n    /// @return info - full deposit information of given account\\n    function getDepositInfo(address account) external view returns (DepositInfo memory info);\\n\\n    /// @return the deposit (for gas payment) of the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * add to the deposit of the given account\\n     */\\n    function depositTo(address account) external payable;\\n\\n    /**\\n     * add to the account's stake - amount and delay\\n     * any pending unstake is first cancelled.\\n     * @param _unstakeDelaySec the new lock duration before the deposit can be withdrawn.\\n     */\\n    function addStake(uint32 _unstakeDelaySec) external payable;\\n\\n    /**\\n     * attempt to unlock the stake.\\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\\n     */\\n    function unlockStake() external;\\n\\n    /**\\n     * withdraw from the (unlocked) stake.\\n     * must first call unlockStake and wait for the unstakeDelay to pass\\n     * @param withdrawAddress the address to send withdrawn value.\\n     */\\n    function withdrawStake(address payable withdrawAddress) external;\\n\\n    /**\\n     * withdraw from the deposit.\\n     * @param withdrawAddress the address to send withdrawn value.\\n     * @param withdrawAmount the amount to withdraw.\\n     */\\n    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external;\\n}\\n\",\"keccak256\":\"0x61562da096c3c3da5755bbb5b552ea713723d7be36975cd401022ff321753b73\",\"license\":\"GPL-3.0-only\"},\"contracts/interfaces/UserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-inline-assembly */\\n\\n/**\\n * User Operation struct\\n * @param sender the sender account of this request.\\n * @param nonce unique value the sender uses to verify it is not a replay.\\n * @param initCode if set, the account contract will be created by this constructor/\\n * @param callData the method call to execute on this account.\\n * @param callGasLimit the gas limit passed to the callData method call.\\n * @param verificationGasLimit gas used for validateUserOp and validatePaymasterUserOp.\\n * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\\n * @param maxFeePerGas same as EIP-1559 gas parameter.\\n * @param maxPriorityFeePerGas same as EIP-1559 gas parameter.\\n * @param paymasterAndData if set, this field holds the paymaster address and paymaster-specific data. the paymaster will pay for the transaction instead of the sender.\\n * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n */\\nstruct UserOperation {\\n    address sender;\\n    uint256 nonce;\\n    bytes initCode;\\n    bytes callData;\\n    uint256 callGasLimit;\\n    uint256 verificationGasLimit;\\n    uint256 preVerificationGas;\\n    uint256 maxFeePerGas;\\n    uint256 maxPriorityFeePerGas;\\n    bytes paymasterAndData;\\n    bytes signature;\\n}\\n\\n/**\\n * Utility functions helpful when working with UserOperation structs.\\n */\\nlibrary UserOperationLib {\\n    function getSender(UserOperation calldata userOp) internal pure returns (address) {\\n        address data;\\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\\n        assembly {\\n            data := calldataload(userOp)\\n        }\\n        return address(uint160(data));\\n    }\\n\\n    //relayer/block builder might submit the TX with higher priorityFee, but the user should not\\n    // pay above what he signed for.\\n    function gasPrice(UserOperation calldata userOp) internal view returns (uint256) {\\n        unchecked {\\n            uint256 maxFeePerGas = userOp.maxFeePerGas;\\n            uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n            if (maxFeePerGas == maxPriorityFeePerGas) {\\n                //legacy mode (for networks that don't support basefee opcode)\\n                return maxFeePerGas;\\n            }\\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n        }\\n    }\\n\\n    function pack(UserOperation calldata userOp) internal pure returns (bytes memory ret) {\\n        //lighter signature scheme. must match UserOp.ts#packUserOp\\n        bytes calldata sig = userOp.signature;\\n        // copy directly the userOp from calldata up to (but not including) the signature.\\n        // this encoding depends on the ABI encoding of calldata, but is much lighter to copy\\n        // than referencing each field separately.\\n        assembly {\\n            let ofs := userOp\\n            let len := sub(sub(sig.offset, ofs), 32)\\n            ret := mload(0x40)\\n            mstore(0x40, add(ret, add(len, 32)))\\n            mstore(ret, len)\\n            calldatacopy(add(ret, 32), ofs, len)\\n        }\\n    }\\n\\n    function hash(UserOperation calldata userOp) internal pure returns (bytes32) {\\n        return keccak256(pack(userOp));\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\",\"keccak256\":\"0x9d677e4299f7c97c820f0c444739bd39cda943def1c38cdb7960038191697bbc\",\"license\":\"GPL-3.0\"},\"contracts/misc/BundlerHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.15;\\n\\nimport \\\"../interfaces/IEntryPoint.sol\\\";\\n\\ncontract BundlerHelper {\\n    function getUserOpHashes(IEntryPoint entryPoint, UserOperation[] memory userOps)\\n        external\\n        view\\n        returns (bytes32[] memory ret)\\n    {\\n        ret = new bytes32[](userOps.length);\\n        for (uint256 i = 0; i < userOps.length; i++) {\\n            ret[i] = entryPoint.getUserOpHash(userOps[i]);\\n        }\\n    }\\n\\n    function getCodeHashes(address[] memory addresses) public view returns (bytes32) {\\n        bytes32[] memory hashes = new bytes32[](addresses.length);\\n        for (uint256 i = 0; i < addresses.length; i++) {\\n            hashes[i] = addresses[i].codehash;\\n        }\\n        bytes memory data = abi.encode(hashes);\\n        return keccak256(data);\\n    }\\n}\\n\",\"keccak256\":\"0x7d32074dd3a2a241c4a214d565c17547f907da7207ae2b52827b6a6092560c32\",\"license\":\"GPL-3.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061094c806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80633024e00c1461003b5780637b34b62114610064575b600080fd5b61004e610049366004610438565b610085565b60405161005b919061061a565b60405180910390f35b61007761007236600461065e565b6101a2565b60405190815260200161005b565b6060815167ffffffffffffffff8111156100a1576100a16102ce565b6040519080825280602002602001820160405280156100ca578160200160208202803683370190505b50905060005b825181101561019b578373ffffffffffffffffffffffffffffffffffffffff1663a6193531848381518110610107576101076106f8565b60200260200101516040518263ffffffff1660e01b815260040161012b9190610792565b602060405180830381865afa158015610148573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061016c919061089e565b82828151811061017e5761017e6106f8565b602090810291909101015280610193816108b7565b9150506100d0565b5092915050565b600080825167ffffffffffffffff8111156101bf576101bf6102ce565b6040519080825280602002602001820160405280156101e8578160200160208202803683370190505b50905060005b835181101561025757838181518110610209576102096106f8565b602002602001015173ffffffffffffffffffffffffffffffffffffffff163f82828151811061023a5761023a6106f8565b60209081029190910101528061024f816108b7565b9150506101ee565b5060008160405160200161026b919061061a565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190528051602090910120949350505050565b73ffffffffffffffffffffffffffffffffffffffff811681146102cb57600080fd5b50565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051610160810167ffffffffffffffff81118282101715610321576103216102ce565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561036e5761036e6102ce565b604052919050565b600067ffffffffffffffff821115610390576103906102ce565b5060051b60200190565b80356103a5816102a9565b919050565b600082601f8301126103bb57600080fd5b813567ffffffffffffffff8111156103d5576103d56102ce565b61040660207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601610327565b81815284602083860101111561041b57600080fd5b816020850160208301376000918101602001919091529392505050565b6000806040838503121561044b57600080fd5b8235610456816102a9565b915060208381013567ffffffffffffffff8082111561047457600080fd5b818601915086601f83011261048857600080fd5b813561049b61049682610376565b610327565b81815260059190911b830184019084810190898311156104ba57600080fd5b8585015b83811015610609578035858111156104d557600080fd5b8601610160818d037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe001121561050a57600080fd5b6105126102fd565b61051d89830161039a565b815260408201358982015260608201358781111561053a57600080fd5b6105488e8b838601016103aa565b60408301525060808201358781111561056057600080fd5b61056e8e8b838601016103aa565b60608301525060a0820135608082015260c082013560a082015260e082013560c082015261010082013560e082015261012082013561010082015261014080830135888111156105bd57600080fd5b6105cb8f8c838701016103aa565b61012084015250610160830135888111156105e557600080fd5b6105f38f8c838701016103aa565b91830191909152508452509186019186016104be565b508096505050505050509250929050565b6020808252825182820181905260009190848201906040850190845b8181101561065257835183529284019291840191600101610636565b50909695505050505050565b6000602080838503121561067157600080fd5b823567ffffffffffffffff81111561068857600080fd5b8301601f8101851361069957600080fd5b80356106a761049682610376565b81815260059190911b820183019083810190878311156106c657600080fd5b928401925b828410156106ed5783356106de816102a9565b825292840192908401906106cb565b979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000815180845260005b8181101561074d57602081850181015186830182015201610731565b8181111561075f576000602083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526107b960208201835173ffffffffffffffffffffffffffffffffffffffff169052565b60208201516040820152600060408301516101608060608501526107e1610180850183610727565b915060608501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08086850301608087015261081d8483610727565b9350608087015160a087015260a087015160c087015260c087015160e087015260e087015191506101008281880152808801519250506101208281880152808801519250506101408187860301818801526108788584610727565b9088015187820390920184880152935090506108948382610727565b9695505050505050565b6000602082840312156108b057600080fd5b5051919050565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361090f577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b506001019056fea2646970667358221220599da9903b066c0a9e9be399310647e0e311721d92753e4a203738add53e585864736f6c634300080f0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c80633024e00c1461003b5780637b34b62114610064575b600080fd5b61004e610049366004610438565b610085565b60405161005b919061061a565b60405180910390f35b61007761007236600461065e565b6101a2565b60405190815260200161005b565b6060815167ffffffffffffffff8111156100a1576100a16102ce565b6040519080825280602002602001820160405280156100ca578160200160208202803683370190505b50905060005b825181101561019b578373ffffffffffffffffffffffffffffffffffffffff1663a6193531848381518110610107576101076106f8565b60200260200101516040518263ffffffff1660e01b815260040161012b9190610792565b602060405180830381865afa158015610148573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061016c919061089e565b82828151811061017e5761017e6106f8565b602090810291909101015280610193816108b7565b9150506100d0565b5092915050565b600080825167ffffffffffffffff8111156101bf576101bf6102ce565b6040519080825280602002602001820160405280156101e8578160200160208202803683370190505b50905060005b835181101561025757838181518110610209576102096106f8565b602002602001015173ffffffffffffffffffffffffffffffffffffffff163f82828151811061023a5761023a6106f8565b60209081029190910101528061024f816108b7565b9150506101ee565b5060008160405160200161026b919061061a565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190528051602090910120949350505050565b73ffffffffffffffffffffffffffffffffffffffff811681146102cb57600080fd5b50565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051610160810167ffffffffffffffff81118282101715610321576103216102ce565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561036e5761036e6102ce565b604052919050565b600067ffffffffffffffff821115610390576103906102ce565b5060051b60200190565b80356103a5816102a9565b919050565b600082601f8301126103bb57600080fd5b813567ffffffffffffffff8111156103d5576103d56102ce565b61040660207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601610327565b81815284602083860101111561041b57600080fd5b816020850160208301376000918101602001919091529392505050565b6000806040838503121561044b57600080fd5b8235610456816102a9565b915060208381013567ffffffffffffffff8082111561047457600080fd5b818601915086601f83011261048857600080fd5b813561049b61049682610376565b610327565b81815260059190911b830184019084810190898311156104ba57600080fd5b8585015b83811015610609578035858111156104d557600080fd5b8601610160818d037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe001121561050a57600080fd5b6105126102fd565b61051d89830161039a565b815260408201358982015260608201358781111561053a57600080fd5b6105488e8b838601016103aa565b60408301525060808201358781111561056057600080fd5b61056e8e8b838601016103aa565b60608301525060a0820135608082015260c082013560a082015260e082013560c082015261010082013560e082015261012082013561010082015261014080830135888111156105bd57600080fd5b6105cb8f8c838701016103aa565b61012084015250610160830135888111156105e557600080fd5b6105f38f8c838701016103aa565b91830191909152508452509186019186016104be565b508096505050505050509250929050565b6020808252825182820181905260009190848201906040850190845b8181101561065257835183529284019291840191600101610636565b50909695505050505050565b6000602080838503121561067157600080fd5b823567ffffffffffffffff81111561068857600080fd5b8301601f8101851361069957600080fd5b80356106a761049682610376565b81815260059190911b820183019083810190878311156106c657600080fd5b928401925b828410156106ed5783356106de816102a9565b825292840192908401906106cb565b979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000815180845260005b8181101561074d57602081850181015186830182015201610731565b8181111561075f576000602083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526107b960208201835173ffffffffffffffffffffffffffffffffffffffff169052565b60208201516040820152600060408301516101608060608501526107e1610180850183610727565b915060608501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08086850301608087015261081d8483610727565b9350608087015160a087015260a087015160c087015260c087015160e087015260e087015191506101008281880152808801519250506101208281880152808801519250506101408187860301818801526108788584610727565b9088015187820390920184880152935090506108948382610727565b9695505050505050565b6000602082840312156108b057600080fd5b5051919050565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361090f577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b506001019056fea2646970667358221220599da9903b066c0a9e9be399310647e0e311721d92753e4a203738add53e585864736f6c634300080f0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}